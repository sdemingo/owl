#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Agregador de enlaces para usar sobre terminal en un servidor de usuarios
# Por sdemingo
#
#       sdemingo [en] texto-plano.xyz
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


# próximo:
# - marcar enlaces leídos
# - comentar enlaces
# - mostrar comentarios
# - permitir etiquetar enlaces (con una marca aparte en el log)
# - permitir listar por usuario, etiquetas, ...


import sys
import os
import hashlib
from datetime import datetime as dt

OWL_LOGFILE=".owl.log"
USR_DIR="/home"
HTTP_BROWSER="w3m"
GEMINI_BROWSER="amfora"
LINKS_PER_PAGE=10

sorted_marks=[]
link_list={}
user=os.getenv("USER")


##
##  Funciones asociadas a comandos
##

def add(args):
    """
    Comando para añadir enlaces
    """
    stamp=dt.timestamp(dt.today())
    url=str(input("URL: ")).strip()
    title=str(input("Título: "))
    key=hashlib.md5((url+str(stamp)+user).encode()).hexdigest()
    if (not url.startswith("http://")) and (not url.startswith("gemini://")):
        url="http://"+url
    line="%f;add;%s;%s;%s" %(stamp,key,url,title)
    addMark(line)
    link=LinkMark(user,[stamp,"add",key,url,title])
    sorted_marks.append(link)
    link_list[link.key]=link



def listl(args):
    """
    Comando para listar enlaces
    """
    c=1
    for m in sorted_marks:
        print ("[%d] %s"%(c,m.stringHeader()),end="")
        c+=1
        if (c % LINKS_PER_PAGE == 0):
            input("\tPulsa una tecla para seguir o 'q' para abortar ...\n")


def openbrowser(args):
    """
    Comando para abrir enlaces en el browser apropiado
    """
    if (len(args)<1):
        print ("Faltan argumentos")
        return
    try:
        number=int(args[0])
    except:
        print ("Id incorrecto")
        return
    if ((number>0) and (number <= len(sorted_marks))):
        url = sorted_marks[number-1].url
        if url.startswith("gemini://"):
            os.system(GEMINI_BROWSER+" "+sorted_marks[number-1].url)
        else:
            os.system(HTTP_BROWSER+" "+sorted_marks[number-1].url)
    else:
        print ("Id incorrecto")



def vote(args):
    """
    Comando para votar enlaces
    """
    if (len(args)<1):
        print ("Falta id del enlace")
        return
    try:
        number=int(args[0])
    except:
        print ("Id incorrecto")
        return
    if ((number>0) and (number <= len(sorted_marks))):
        key=sorted_marks[number-1].key
        if (user in sorted_marks[number-1].ups):
            print ("Ya votaste este enlace")
        else:
            stamp=dt.timestamp(dt.today())
            addMark("%f;vote;%s" %(stamp,key))
            link=link_list[key]
            link.addVoteFrom(user)
    else:
        print ("Id incorrecto")


def vhelp(args):
    helpmsg='''
    - list: Lista enlaces encontrados.
    - view: Muestra los detalles de un enlace (autor, fecha, comentarios, etc.).
    - add: Agrega un nuevo enlace.
    - vote: Vota un enlace. 
    - open: Abre el enlace en el navegador.
    '''
    print (helpmsg)



def view(args):
    """
    Comando para añadir ver detalles de los enlaces (propietario, fecha, comentarios, ...)
    """
    if (len(args)<1):
        print ("Falta id del enlace")
        return
    try:
        number=int(args[0])
    except:
        print ("Id incorrecto")
        return
    if ((number>0) and (number <= len(sorted_marks))):
        key=sorted_marks[number-1].key
        print ("%s"%sorted_marks[number-1].stringExtended())
    else:
        print ("Id incorrecto")



###
### Enlazado de funciones a comandos
###

cmd={}
cmd["add"]=add
cmd["list"]=listl
cmd["open"]=openbrowser
cmd["vote"]=vote
cmd["help"]=vhelp
cmd["view"]=view




###
###     Otras funciones auxiliares
###

def loadGlobalLog():
    global sorted_marks
    dirs=os.listdir(USR_DIR)
    for d in dirs:
        if os.path.isfile(os.path.join(USR_DIR,d,OWL_LOGFILE)):
            user=d
            loadUserLog(user)
    sorted(sorted_marks,key=lambda m:m.stamp,reverse=True)



def loadUserLog(userlog):
    global sorted_marks
    global link_list

    with open(os.path.join(USR_DIR,userlog,OWL_LOGFILE),'r', encoding="utf-8") as f:
            lines=f.readlines()
    for l in lines:
        fields=l.strip("\n").split(";")
        if (len(fields)>2):
            if (fields[1] == "add"):
                mark=LinkMark(user,fields)
                sorted_marks.append(mark)
                link_list[mark.key]=mark

            if (fields[1] == "vote"):
                key=fields[2]
                link=link_list[key]
                link.addVoteFrom(user)


def addMark(marktext):
    filepath=os.path.join(USR_DIR,user,OWL_LOGFILE)
    with open(filepath,'a', encoding="utf-8") as f:
        f.write(marktext+"\n")    


class LinkMark:
    def __init__(self,user, args):
        self.stamp=args[0]
        self.cmd=args[1]   ##?¿quitar
        self.key=args[2]
        self.url=args[3]
        self.ups={}
        self.title="".join(args[4:]).strip("\n")
        self.user=user

    def stringHeader(self):
        prot="HTTP"
        if (self.url.startswith("gemini://")):
            prot="GEM"
        ups=len(self.ups)
        return "[{0:<4}:{1:>2} ups] {2}\n".format(prot,ups,self.title)

    def stringExtended(self):
        d=dt.fromtimestamp(float(self.stamp)).strftime("%d %b %Y %H:%M")
        prot="HTTP"
        if (self.url.startswith("gemini://")):
            prot="GEM"
        ups=len(self.ups)
        return "%s\t- De %s el %s\n\t- Url: %s"%(self.stringHeader(),self.user,d,self.url)

    def addVoteFrom(self,user):
        self.ups[user]=1 








if __name__=="__main__":
    loadGlobalLog()
    while(True):
        userline = str(input("owl> ")).strip()
        if (len(userline)>0):
            args=userline.split(" ")
            command=args[0]
            if (command=="quit"):
                sys.exit()
            if command in cmd:
                cmd[command](args[1:])
            else:
                print ("orden desconocida. Use help")